# Inicio Para Principiantes, Parte 3: Interfaces
Tag: #interfaces

Comenzamos esta serie con un tutorial de introducción que te introducen a las diferentes características de mecanografiado. También le enseñó cómo instalar TypeScript y sugirió algunas IDEs que puede utilizar para escribir y compilar su propio código de TypeScript.

En el segundo tutorial, cubrimos [diferentes tipos de datos disponibles en TypeScript](https://code.tutsplus.com/tutorials/typescript-for-beginners-basic-data-types--cms-29438) y cómo usarlos pueden ayudarle a evitar muchos errores. Asignar a un tipo de datos como una `string` a una variable particular dice mecanografiado que desea asignar una cadena a ella. Basándose en esta información, mecanografiado puede señalarlo más tarde cuando intenta realizar una operación que no debe hacerse en las cuerdas.

En este tutorial, usted aprenderá sobre las [interfaces en TypeScript](https://www.typescriptlang.org/docs/handbook/interfaces.html). Con interfaces, puede dar un paso más y definir la estructura o tipo de objetos más complejos en el código. Al igual que tipos de variables simples, estos objetos también tendrá que seguir un conjunto de reglas creadas por usted. Esto puede ayudarle a escribir código con más confianza, con menos posibilidades de error.

## Creando Nuestra Primera Interfaz

Digamos que tienes un objeto de lago en el código y usarlo para almacenar información sobre algunos de los [lagos más grande por área](https://en.wikipedia.org/wiki/List_of_lakes_by_area) en el mundo. Este objeto de lago tiene propiedades como el nombre del lago, su área, longitud, profundidad y los países en que existe ese lago.

Los nombres de los lagos se guardará como una cadena. Las longitudes de estos lagos será en kilómetros y serán las áreas en kilómetros cuadrados, pero ambas de estas propiedades serán almacenados como números. Las profundidades de los lagos será en metros, y esto también podría ser un flotador.

Puesto que todos estos lagos son muy grandes, sus costas generalmente no se limitan a un solo país. Se utilizará una matriz de cadenas para almacenar los nombres de todos los países en la orilla de un lago particular. Un valor Boolean puede utilizarse para especificar si el lake es agua salada o agua dulce. El siguiente fragmento de código crea una interfaz para el objeto de nuestro lago.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>interface</code> <code>Lakes {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: string,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: boolean,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: string[]</code></p><p><code>}</code></p></div></td></tr></tbody></table>

La interfaz de `Lakes` contiene el tipo de cada propiedad que vamos a utilizar al crear los objetos de nuestro lago. Si ahora intenta asignar a diferentes tipos de valores a cualquiera de estas propiedades, se producirá un error. Aquí es un ejemplo que almacena información acerca de nuestro primer lago.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>let</code> <code>firstLake: Lakes = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>'Caspian Sea'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: 1199,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: 1025,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: 371000,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: </code><code>false</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: [</code><code>'Kazakhstan'</code><code>, </code><code>'Russia'</code><code>, </code><code>'Turkmenistan'</code><code>, </code><code>'Azerbaijan'</code><code>, </code><code>'Iran'</code><code>]</code></p><p><code>}</code></p></div></td></tr></tbody></table>

Como se puede ver, no importa el orden en que asigna un valor a estas propiedades. Sin embargo, no puede omitir un valor. Usted tendrá que asignar un valor a cada propiedad con el fin de evitar errores al compilar el código.

Esta manera, mecanografiado se asegura de que usted no faltó ninguno de los valores deseados por error. Aquí hay un ejemplo donde olvidamos para asignar el valor de la propiedad de `depth` de un lago.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p></td><td><div><p><code>let</code> <code>secondLake: Lakes = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>'Superior'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: 616,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: 82100,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: [</code><code>'Canada'</code><code>, </code><code>'United States'</code><code>]</code></p><p><code>}</code></p></div></td></tr></tbody></table>

La captura de pantalla siguiente muestra el mensaje de error en código de Visual Studio después de que olvidé de especificar la `depth`. Como se puede ver, el error claramente indica que estamos perdiendo la propiedad `depth` para nuestro objeto de lago.

![Missing Property Values in TypeScript Interface](https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1251/posts/29439/image/secondLake-error.png)

## Haciendo la Propiedades de la Interfaz Opcionales

A veces, puede que necesite una propiedad sólo para algunos objetos específicos. Por ejemplo, supongamos que desea agregar una propiedad para especificar los meses en los que un lago se congela. Si agrega la propiedad directamente a la interfaz, como lo hemos hecho hasta ahora, obtendrá un error para otros lagos que no congelar y por lo tanto no tener ninguna propiedad `frozen`. Asimismo, si agrega esa propiedad a los lagos que se congelan pero no en la declaración de interfaz, se da un error.

En tales casos, puede añadir un signo de interrogación (`?`) después del nombre de una propiedad para establecer como opcional en la declaración de interfaz. Esta manera, no conseguirá un error por falta de propiedades o propiedades desconocidas. En el ejemplo siguiente, se debe dejar claro.

<table><tbody><tr><td><p>01</p><p>02</p><p>03</p><p>04</p><p>05</p><p>06</p><p>07</p><p>08</p><p>09</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p></td><td><div><p><code>interface</code> <code>Lakes {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: string,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: boolean,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: string[],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>frozen?: string[]</code></p><p><code>}</code></p><p><code>let</code> <code>secondLake: Lakes = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>'Superior'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: 406.3,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: 616,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: 82100,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: [</code><code>'Canada'</code><code>, </code><code>'United States'</code><code>]</code></p><p><code>}</code></p><p><code>let</code> <code>thirdLake: Lakes = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>'Baikal'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: 1637,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: 636,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: 31500,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: [</code><code>'Russia'</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>frozen: [</code><code>'January'</code><code>, </code><code>'February'</code><code>, </code><code>'March'</code><code>, </code><code>'April'</code><code>, </code><code>'May'</code><code>]</code></p><p><code>}</code></p></div></td></tr></tbody></table>

## Utilizando el Indice de Firmas

Propiedades opcionales son útiles cuando un buen número de los objetos van a utilizarlos. Sin embargo, ¿qué pasa si cada lago también tenía su propio conjunto de propiedades como las actividades económicas, la población de diferentes tipos de flora y fauna floreciente en ese lago, o los poblados alrededor del lago? Agregar muchos diferentes propiedades dentro de la declaración de la propia interfaz y hacerlos opcional no son ideal.

Como solución, TypeScript permite añadir propiedades extras a objetos específicos con la ayuda de las firmas del índice. Agregar una firma de índice a la declaración de interfaz le permite especificar cualquier número de propiedades de diferentes objetos que están creando. Necesita realizar los siguientes cambios en la interfaz.

En este ejemplo, he utilizado una firma de índice para agregar información acerca de diferentes asentamientos alrededor de los lagos. Ya que cada lago tendrá sus propios asentamientos, no utilizando propiedades opcionales habría sido una buena idea.

<table><tbody><tr><td><p>01</p><p>02</p><p>03</p><p>04</p><p>05</p><p>06</p><p>07</p><p>08</p><p>09</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></td><td><div><p><code>interface</code> <code>Lakes {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: string,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: boolean,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: string[],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>frozen?: string[],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>[extraProp: string]: any</code></p><p><code>}</code></p><p><code>let</code> <code>fourthLake: Lakes = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>'Tanganyika'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depth: 1470,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>length: 676,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>area: 32600,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>isFreshwater: </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>countries: [</code><code>'Burundi'</code><code>, </code><code>'Tanzania'</code><code>, </code><code>'Zambia'</code><code>, </code><code>'Congo'</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>kigoma:</code><code>'Tanzania'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>kalemie: </code><code>'Congo'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>bujumbura: </code><code>'Burundi'</code></p><p><code>}</code></p></div></td></tr></tbody></table>

Como otro ejemplo, supongamos que está creando un juego con diferentes tipos de enemigos. Todos estos enemigos tienen algunas características comunes como su tamaño y la salud. Estas propiedades se pueden incluir en la declaración de interfaz directamente. Si cada categoría de estos enemigos tiene un conjunto único de las armas, esas armas pueden ser incluidas con la ayuda de una firma de índice.

## Propiedades de Sólo Lectura

Cuando se trabaja con objetos diferentes, puede que necesite trabajar con propiedades que sólo pueden modificarse cuando creamos primero el objeto. Puede marcar estas propiedades como `readonly` en la declaración de interfaz. Esto es similar al uso de la palabra clave `const`, sino `const` se supone para ser utilizado con variables, mientras que `readonly` se entiende por propiedades.

Escrito permite realizar arreglos de discos de sólo lectura mediante `ReadonlyArray<T>`. Crear una matriz de sólo lectura resultará en la eliminación de todos los métodos mutando desde eso. Esto se hace para asegurarse de que no puede cambiar el valor de los elementos individuales más adelante. Aquí es un ejemplo del uso de matrices y propiedades de sólo lectura en las declaraciones de interfaz.

<table><tbody><tr><td><p>01</p><p>02</p><p>03</p><p>04</p><p>05</p><p>06</p><p>07</p><p>08</p><p>09</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><div><p><code>interface</code> <code>Enemy {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>readonly size: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>health: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>range: number,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>readonly damage: number</code></p><p><code>}</code></p><p><code>let</code> <code>tank: Enemy = {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>size: 50,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>health: 100,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>range: 60,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>damage: 12</code></p><p><code>}</code></p><p><code>tank.health = 95;</code></p><p><code>tank.damage = 10;</code></p></div></td></tr></tbody></table>

## Funciones e Interfaces

También puede utilizar interfaces para describir un tipo de función. Esto requiere que la función de una firma llamada con su lista de parámetros y tipo de valor devuelto. También debe proporcionar un nombre y un tipo para cada uno de los parámetros. Aquí está un ejemplo:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>interface</code> <code>EnemyHit {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>(name: Enemy, damageDone: number): number;</code></p><p><code>}</code></p><p><code>let</code> <code>tankHit: EnemyHit = </code><code>function</code><code>(tankName: Enemy, damageDone: number) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tankName.health -= damageDone;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>tankName.health;</code></p><p><code>}</code></p></div></td></tr></tbody></table>

En el código anterior, hemos declarado una interfaz de función y utiliza para definir una función que resta el daño infligido a un tanque de su salud. Como se puede ver, no tienes que utilizar el mismo nombre para los parámetros en la declaración de la interfaz y la definición del código para trabajar.

## Reflexiones Finales

Este tutorial le presenta a interfaces y cómo usted puede utilizar para asegurarse de que está escribiendo código más robusto. Ahora debe ser capaz de crear sus propias interfaces con características opcionales y de sólo lectura.

También aprendió a utilizar índice firmas para agregar una variedad de otras propiedades a un objeto que no están incluidos en la declaración de interfaz. Este tutorial fue significado para comenzar con interfaces por escrito, y usted puede leer más sobre este tema en la [documentación oficial](https://www.typescriptlang.org/docs/handbook/interfaces.html).

En el siguiente tutorial, usted aprenderá acerca de las clases en TypeScript. Si usted tiene alguna pregunta relacionada con las interfaces, hágamelo saber en los comentarios.